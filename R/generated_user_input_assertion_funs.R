# generated by dbc::generate_script_from_expressions.
# do no modify by hand!

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_all_are_TRUE <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(all(x %in% TRUE))
  )
  fail_messages <- c(
    "Not all elements of `${x_nm}` were TRUE"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_atom_is_in_set <- function(
  x,
  x_nm = NULL,
  call = NULL,
  set
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1),
    quote(x %in% set)
  )
  fail_messages <- c(
    NA_character_,
    "object `${x_nm}` = ${x} was not in set of expected values (first ten): ${deparse(utils::head(set, 10L))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_data_table_has_no_duplicates <- function(
  x,
  x_nm = NULL,
  call = NULL,
  by = names(x)
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(!(dup <- duplicated(x, by = by)))
  )
  fail_messages <- c(
    "In total ${n_fail} rows of data.table ${deparse1(x_nm)} were duplicates (by ${deparse1(by)}); first five row numbers that were duplicated: ${deparse1(utils::head(which(dup), 5))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_dir_exists <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(bad_dirs <- x[!dir.exists(x)]) == 0L)
  )
  fail_messages <- c(
    "the following directory/directories in object `${x_nm}` do not exist: ${deparse(bad_dirs)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_file_exists <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(bad_files <- x[!file.exists(x)]) == 0L)
  )
  fail_messages <- c(
    "the following file(s) in object `${x_nm}` do not exist: ${bad_files}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_has_class <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_class
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, required_class))
  )
  fail_messages <- c(
    "expected object `${x_nm}` to have class ${required_class}, but it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_has_length <- function(
  x,
  x_nm = NULL,
  call = NULL,
  expected_length
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == expected_length)
  )
  fail_messages <- c(
    "object `${x_nm}` had length ${length(x)} instead of ${expected_length}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_has_names <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_names
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(!is.null(names(x))),
    quote(length(miss_nms <- setdiff(required_names, names(x))) == 0L)
  )
  fail_messages <- c(
    "object `${x_nm}` did not have any names",
    "object `${x_nm}` did not have the following expected names: ${deparse(miss_nms)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_has_no_duplicates <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(!duplicated(x))
  )
  fail_messages <- c(
    "In total ${n_fail} elements of object/param `${x_nm}` were duplicates; first five values that were duplicated: ${deparse(utils::head(unique(x[duplicated(x)]), 5L))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_has_one_of_classes <- function(
  x,
  x_nm = NULL,
  call = NULL,
  classes
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, classes))
  )
  fail_messages <- c(
    "expected object `${x_nm}` to have class ${classes}, but it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_has_only_names <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_names
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(!is.null(names(x))),
    quote(length(miss_nms <- setdiff(required_names, names(x))) == 0L),
    quote(length(extra_nms <- setdiff(names(x), required_names)) == 0L)
  )
  fail_messages <- c(
    "object `${x_nm}` did not have any names",
    "object `${x_nm}` did not have the following expected names: ${deparse(miss_nms)}",
    "object `${x_nm}` had the following unexpected names: ${deparse(extra_nms)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_inherits <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_class
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, required_class))
  )
  fail_messages <- c(
    "expected object `${x_nm}` to have class ${required_class}, but it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_assertion_type <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1),
    quote(is.character(x)),
    quote(!is.na(x)),
    quote(x %in% dbc::assertion_types())
  )
  fail_messages <- c(
    "`${x_nm}` was not atomic",
    "`${x_nm}` was not a string",
    "`${x_nm}` was NA",
    "`${x_nm}` was not one of the strings given by dbc::assertion_types()"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_between_exclusive <- function(
  x,
  x_nm = NULL,
  call = NULL,
  lo,
  hi
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(dbc::is_between_exclusive(x = x, lo = lo, hi = hi))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were outside exclusive bounds ${lo}, ${hi}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_between_inclusive <- function(
  x,
  x_nm = NULL,
  call = NULL,
  lo,
  hi
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(dbc::is_between_inclusive(x = x, lo = lo, hi = hi))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were outside inclusive bounds ${lo}, ${hi}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_call <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.call(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a call object; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.character(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.character(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.character(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.character(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.character(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.character(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_character_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.character(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class character; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data.frame <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.data.frame(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.frame; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data.frame_with_required_names <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_names
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.data.frame(x)),
    quote(length(miss_nms <- setdiff(required_names, names(x))) == 0L)
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.frame; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` did not have the following expected columns: ${deparse(miss_nms)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data.table <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'data.table'))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.table; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data.table_with_required_names <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_names
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'data.table')),
    quote(length(miss_nms <- setdiff(required_names, names(x))) == 0L)
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.table; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` did not have the following expected columns: ${deparse(miss_nms)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data_frame <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.data.frame(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.frame; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data_table <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'data.table'))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.table; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_data_table_with_required_names <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_names
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'data.table')),
    quote(length(miss_nms <- setdiff(required_names, names(x))) == 0L)
  )
  fail_messages <- c(
    "object `${x_nm}` was not a data.table; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` did not have the following expected columns: ${deparse(miss_nms)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'Date'))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(inherits(x, 'Date'))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'Date')),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(inherits(x, 'Date')),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'Date')),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'Date')),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_Date_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'Date')),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class Date; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_gtezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x >= 0)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were < 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_gtezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x >= 0),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_gtezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x >= 0),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_gtzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x > 0)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were <= 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_gtzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x > 0),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_gtzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x > 0),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_ltezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x <= 0)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_ltezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x <= 0),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_ltezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x <= 0),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_ltzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x < 0)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_ltzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x < 0),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_ltzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x < 0),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_gtezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x >= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_gtezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x >= 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_gtezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x >= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_gtzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x > 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_gtzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x > 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_gtzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x > 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_ltezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x <= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_ltezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x <= 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_ltezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x <= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_ltzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.double(x)),
    quote(x < 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_ltzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x < 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_ltzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(x < 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_double_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.double(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class numeric; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_environment <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.environment(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not an environment object"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_expression <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.expression(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not an R expression object; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.factor(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.factor(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.factor(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.factor(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.factor(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.factor(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.factor(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class factor; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_factor_with_levels <- function(
  x,
  x_nm = NULL,
  call = NULL,
  expected_levels
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.factor(x)),
    quote(length(extra_levels <- setdiff(levels(x), expected_levels)) == 0L),
    quote(length(miss_levels <- setdiff(expected_levels, levels(x))) == 0L)
  )
  fail_messages <- c(
    "object `${x_nm}` is not a factor; instead it had class(es) ${deparse(class(x))}",
    "factor object `${x_nm}` had these unexpected levels: ${deparse(extra_levels)}",
    "factor object `${x_nm}` did not have these expected levels: ${deparse(miss_levels)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_function <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.function(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a function; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_function_with_required_argument_names <- function(
  x,
  x_nm = NULL,
  call = NULL,
  required_argument_names
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.function(x)),
    quote(all(required_argument_names %in% names(formals(x))))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a function",
    "object `${x_nm}` did not have all required arguments ${deparse(required_argument_names)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_gt <- function(
  x,
  x_nm = NULL,
  call = NULL,
  lo
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > lo)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= ${lo}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_gte <- function(
  x,
  x_nm = NULL,
  call = NULL,
  lo
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= lo)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < ${lo}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_gtezero <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_gtzero <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.integer(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_gtezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x >= 0),
    quote(is.integer(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_gtezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.integer(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_gtezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.integer(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_gtzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x > 0),
    quote(is.integer(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_gtzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.integer(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_gtzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.integer(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_ltezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.integer(x)),
    quote(x <= 0)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_ltezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x <= 0),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_ltezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x <= 0),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_ltzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.integer(x)),
    quote(x < 0)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_ltzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x < 0),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_ltzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x < 0),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.integer(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_gtezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x >= 0),
    quote(is.integer(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_gtezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.integer(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_gtezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.integer(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_gtzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x > 0),
    quote(is.integer(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_gtzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.integer(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_gtzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.integer(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_ltezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.integer(x)),
    quote(x <= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_ltezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x <= 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_ltezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x <= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_ltzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.integer(x)),
    quote(x < 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_ltzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x < 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_ltzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(x < 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_integer_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.integer(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class integer; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_language_object <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.language(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not an R language object; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_list <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'list'))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class list"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.logical(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.logical(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.logical(x)),
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.logical(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.logical(x)),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.logical(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_logical_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.logical(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class logical; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_lt <- function(
  x,
  x_nm = NULL,
  call = NULL,
  hi
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x < hi)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were >= ${hi}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_lte <- function(
  x,
  x_nm = NULL,
  call = NULL,
  hi
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x <= hi)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were > ${hi}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_ltezero <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x <= 0)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were > 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_ltzero <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x < 0)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were >= 0"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.matrix(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a matrix"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_name <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.name(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a name object; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_named <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(!is.null(names(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` did not have any names"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_named_list <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'list')),
    quote(!is.null(names(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class list",
    "object `${x_nm}` did not have any names"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_nonNA <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(if (!is.function(x)) !is.na(x) else TRUE)
  )
  fail_messages <- c(
    "object `${x_nm}` had ${n_fail} NA values - none are allowed"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_NULL <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.null(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not NULL"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_gtezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x >= 0),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_gtezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.matrix(x)),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_gtezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_gtzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x > 0),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_gtzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.matrix(x)),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_gtzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_ltezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x <= 0),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_ltezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x <= 0),
    quote(is.matrix(x)),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_ltezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x <= 0),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_ltzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x < 0),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_ltzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x < 0),
    quote(is.matrix(x)),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_ltzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x < 0),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.matrix(x)),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_gtezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x >= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_gtezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_gtezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x >= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were < 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_gtzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x > 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_gtzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_gtzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x > 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were <= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_ltezero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x <= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_ltezero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x <= 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_ltezero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x <= 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were > 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_ltzero_atom <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == 1L),
    quote(x < 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "length of object `${x_nm}` was ${length(x)} instead of 1",
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_ltzero_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x < 0),
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_ltzero_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x < 0),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were >= 0",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_matrix <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.matrix(x)),
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a matrix",
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_nonNA_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(if (!is.function(x)) !is.na(x) else TRUE),
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` had ${n_fail} NA values - none are allowed",
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_number_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.numeric(x)),
    quote(!is.list(x)),
    quote(is.null(dim(x)))
  )
  fail_messages <- c(
    "object `${x_nm}` was not a number; instead it had class(es) ${deparse(class(x))}",
    "object `${x_nm}` was a list",
    "object `${x_nm}` had dimensions but was expected to have none"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_numeric <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.numeric(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not numeric; instead it had class(es) ${deparse(class(x))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_of_length <- function(
  x,
  x_nm = NULL,
  call = NULL,
  expected_length
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(length(x) == expected_length)
  )
  fail_messages <- c(
    "object `${x_nm}` had length ${length(x)} instead of ${expected_length}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_report_df <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.data.frame(x)),
    quote(length(miss_col_nms <- setdiff(names(get_report_df_template()), names(x))) == 0L)
  )
  fail_messages <- c(
    "`${x_nm}` was not a data.frame",
    "Following columns were expected but not in `${x_nm}`: ${deparse(miss_col_nms)}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_TRUE <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(x %in% TRUE)
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` were FALSE or NA"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_uniquely_named <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(!is.null(names(x))),
    quote((n_unique_names <- length(unique(names(x)))) == length(x))
  )
  fail_messages <- c(
    "object `${x_nm}` did not have any names",
    "not every element of object `${x_nm}` has a different name"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_uniquely_named_list <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(inherits(x, 'list')),
    quote(!is.null(names(x))),
    quote((n_unique_names <- length(unique(names(x)))) == length(x))
  )
  fail_messages <- c(
    "object `${x_nm}` was not of class list",
    "object `${x_nm}` did not have any names",
    "not every element of object `${x_nm}` has a different name"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_is_vector <- function(
  x,
  x_nm = NULL,
  call = NULL
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(is.null(dim(x))),
    quote(!is.list(x))
  )
  fail_messages <- c(
    "object `${x_nm}` had dimensions but was expected to have none",
    "object `${x_nm}` was a list"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_match_regex <- function(
  x,
  x_nm = NULL,
  call = NULL,
  grepl.arg.list = list()
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote({grepl.arg.list[['x']] <- x; t <- do.call(grepl, grepl.arg.list); t})
  )
  fail_messages <- c(
    "${n_fail} elements of `${x_nm}` did not match regex ${deparse(grepl.arg.list[['pattern']])}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

# generated by dbc::generate_script_from_expressions.
# do no modify by hand!
#' @rdname assertions
#' @export
assert_user_input_vector_elems_are_in_set <- function(
  x,
  x_nm = NULL,
  call = NULL,
  set
) {
  dbc::handle_args_inplace()
  assertion_type <- "user_input"
  expressions <- list(
    quote(in_set <- x %in% set)
  )
  fail_messages <- c(
    "some values of object `${x_nm}` were not in set of expected values. First ten bad values: ${deparse1(utils::head(unique(x[!in_set]), 10L))}. First ten elements in set of expected values: ${deparse1(utils::head(set, 10L))}"
  )
  for (i in seq_along(expressions)) {
    dbc::assertion_eval(
      expression = expressions[[i]],
      fail_message = fail_messages[i],
      assertion_type = assertion_type,
      x_nm = x_nm,
      call = call
    )
  }
}

