% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/function_generation.R
\name{expressions_to_reports_to_assertions}
\alias{expressions_to_reports_to_assertions}
\alias{expressions_to_report}
\alias{report_to_assertion}
\title{Tests to Reports to Assertions}
\usage{
expressions_to_report(
  expressions,
  fail_messages = NULL,
  pass_messages = NULL,
  env = parent.frame(1L),
  call = NULL
)

report_to_assertion(
  report_df,
  assertion_type = "general",
  raise_error_call = NULL
)
}
\arguments{
\item{expressions}{\verb{[character, list]} (mandatory, no default)
\itemize{
\item \code{character}: vector of expressions to perform; after parsing each string
the evaluated expression must return a logical vector or \code{NULL},
where \code{NULL} is interpreted as pass
\item \code{list}: each element is either a character string as above or a language
object (see e.g. \link{quote}) which is deparsed into a string
}}

\item{fail_messages}{\verb{[NULL, character]} (optional, default \code{NULL})
\itemize{
\item \code{NULL}: use \code{"at least one FALSE value in test: ${test}"}
\item \code{character}: use these messages (one for each test); \code{NA_character_}
values are replaced with the same message as when this argument is
\code{NULL}
}

messages (one for each test) to include in report upon failure; see section
\strong{Interpolation in messages}}

\item{pass_messages}{\verb{[NULL, character]} (optional, default \code{NULL})
\itemize{
\item \code{NULL}: use \code{"all were TRUE in test: ${test}"}
\item \code{character}: use these messages (one for each test); \code{NA_character_}
values are replaced with the same message as when this argument is
\code{NULL}
}

as \code{fail_messages} but for tests successes}

\item{env}{\verb{[environment]} (optional, default \code{parent.frame(1L)})

a new environment is created for evaluating each test given in \code{tests};
this environment will be the parent environment of each of the temporary
environments; the default is the parent environment of the function execution
environment}

\item{call}{\verb{[language, NULL]} (optional, default \code{NULL})
\itemize{
\item \code{language}: an R language object such as one produced by \link{match.call} or
\code{quote}; this call will be reported in an error
\item \code{NULL}: the call is attempted to be inferred
}}

\item{report_df}{\verb{[data.frame]} (mandatory, no default)

a report \code{data.frame} as returned by \code{expressions_to_report}}

\item{assertion_type}{\verb{[character]}
(default usually \code{"general"})

Must be exactly one of the following:
\itemize{
\item \code{"general"}: just says that assertions did not pass without information
as to whose fault this was --- just that some object was not as expected
\item \code{"input"}: assertion error messages direct the attention towards the
inputs (arguments) of guilty function
\item \code{"user_input"}: the end-user is directed to adjust their arguments.
\item \code{"prod_input"}: the assertion error is considered to be an internal error,
and the end-user is directed to report it; the inputs of some function
were not as expected
\item \code{"dev_input"}: only the developer is notified (see
\verb{[dbc::set_dev_mode]})
\item \code{"prod_output"}: like \code{"prod_input"}, but the output of some function
was not as expected
\item \code{"dev_output"}: like \code{"prod_output"}, but only raised in development mode
(see \verb{[dbc::set_dev_mode]})
\item \code{"prod_interim"}: like \code{"prod_input"}, but the interim result somewhere
was not as expected
\item \code{"dev_interim"}: like \code{"prod_interim"}, but only raised in development mode
(see \verb{[dbc::set_dev_mode]})
}}

\item{raise_error_call}{\verb{[NULL, language]} (optional, default \code{NULL})

the call to display in the error call; passed to arg \code{call} of
\link[base:conditions]{base::simpleError}.
\itemize{
\item \code{NULL}: use the parent call; when this function is called in another
function (as it is intended to be used), the function call of the
surrounding function is used; see \strong{Examples}
\item \code{language}: this call is used as-is.
}}
}
\value{
For \code{expressions_to_report}, a \code{data.frame} with columns
\itemize{
\item \code{test}: argument \code{tests} as-is
\item \code{error}: the error message if the test resulted in an error; \code{NA} if it
did not
\item \code{pass}: \code{TRUE} if corresponding test evaluated to logical and all were
\code{TRUE}, otherwise \code{FALSE} (i.e. any \code{NA} values leads to \code{FALSE})
\item \code{n_fail}: number of elements of result of test that were \code{FALSE} or \code{NA};
if result was not a logical vector of length greater than one, this is \code{NA}
\item \code{wh_fail}: integer vector of positions of test result that were \code{FALSE}
or \code{NA}; if result was not a logical vector of length greater than one,
this is \code{NA}
\item \code{message}: the corresponding \code{fail_messages} or \code{pass_messages}
element (after interpolation) depending on \code{pass}
}
}
\description{
Collect tests into a report data.frame, raise assertion errors in failed
tests in report.
}
\section{Interpolation in messages}{

\code{fail_messages} and \code{pass_messages} can use variables you create in a test
and information created based on the result of the test. For an individual
message, you may include any of the variables listed in \strong{Value} for that
test except the message itself by using the syntax \verb{$\{object\}} in your
test string; e.g. \code{"this many failed: ${n_fail}"}. You may include any
variables you created in the test, using the same logic, e.g. with test
\code{"(len <- length(x)) == 1L"} you may do \code{"expected length 1, got ${len}"}.
Finding variables to interpolate into the string is searched for in the
set of variables created in your test first and then in the variables
derived from the result of the test. You may also interpolate any
transformations of the available variables: e.g.
\code{"${round(100 * n_fail / length(x))} \% were invalid"}
}

\examples{
# expressions_to_report

a <- 1:5
b <- 1:5
# pass
expressions_to_report(
  expressions = "a == b"
)
# pass
expressions_to_report(
  expressions = list(quote(a == b))
)
# expressions_to_report raises error
out <- tryCatch(expressions_to_report(
  expressions = a == (b + 1)
), error = function(e) e)
stopifnot(inherits(out, "error"))
# fail
expressions_to_report(
  expressions = "a == (b + 1)"
)
# expressions_to_report does not raise error, but shows it in output
expressions_to_report(
  expressions = "a == d"
)
# report to assertion

# pass
report_df <- expressions_to_report("1 == 1")
report_to_assertion(report_df)

# fail
report_df <- expressions_to_report("1 == 2")
tryCatch(
  report_to_assertion(report_df),
  error = function(e) e
)

# 2 passes, 2 failures
report_df <- expressions_to_report(c("1 == 2", "1 == 1", "2 == 2", "2 == 1"))
tryCatch(
  report_to_assertion(report_df),
  error = function(e) e
)

my_fun <- function(my_arg) {
  report_to_assertion(expressions_to_report("is.character(my_arg)"))
}
tryCatch(
  my_fun(my_arg = 1L),
  error = function(e) e
)
}
