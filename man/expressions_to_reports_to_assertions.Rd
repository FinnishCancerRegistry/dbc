% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/function_generation.R
\name{expressions_to_reports_to_assertions}
\alias{expressions_to_reports_to_assertions}
\alias{expressions_to_report}
\alias{report_to_assertion}
\title{Tests to Reports to Assertions}
\usage{
expressions_to_report(
  expressions,
  fail_messages = NULL,
  pass_messages = NULL,
  env = parent.frame(1L),
  call = NULL
)

report_to_assertion(
  report_df,
  assertion_type = "general",
  raise_error_call = NULL
)
}
\arguments{
\item{expressions}{\verb{[character, list]} (no default)
\itemize{
\item \code{character}: vector of expressions to perform; after parsing each string
the evaluated expression must return a logical vector or \code{NULL},
where \code{NULL} is interpreted as pass
\item \code{list}: each element is either a character string as above or a language
object (see e.g. \link{quote}) which is deparsed into a string
}}

\item{fail_messages}{\verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: use \code{"at least one FALSE value in test: ${test}"}
\item \code{character}: use these messages (one for each test); \code{NA_character_}
values are replaced with the same message as when this argument is
\code{NULL}
}

messages (one for each test) to include in report upon failure; see section
\strong{Interpolation in messages}}

\item{pass_messages}{\verb{[NULL, character]} (default \code{NULL})
\itemize{
\item \code{NULL}: use \code{"all were TRUE in test: ${test}"}
\item \code{character}: use these messages (one for each test); \code{NA_character_}
values are replaced with the same message as when this argument is
\code{NULL}
}

as \code{fail_messages} but for tests successes}

\item{env}{\verb{[environment]} (default \code{parent.frame(1L)})

\code{env} will be the parent environment of the environment where each element
of \code{expressions} is evaluated. A new, separate environment is created for
each separate expression (\emph{expression evaluation environment}).
They all have \code{env} as the parent environment (\emph{context environment}).

\code{env} is also used in interpolation --- see section
\strong{Message interpolation}.}

\item{call}{\verb{[language, NULL]} (optional, default \code{NULL})
\itemize{
\item \code{language}: an R language object such as one produced by \link{match.call} or
\code{quote}; this call will be reported in an error
\item \code{NULL}: the call is attempted to be inferred
}}

\item{report_df}{\verb{[data.frame]} (no default)

a report \code{data.frame} as returned by \code{expressions_to_report}}

\item{assertion_type}{\verb{[character]}
(default usually \code{"general"})

Must be exactly one of the following:
\itemize{
\item \code{"general"}: just says that assertions did not pass without information
as to whose fault this was --- just that some object was not as expected
\item \code{"input"}: assertion error messages direct the attention towards the
inputs (arguments) of guilty function
\item \code{"user_input"}: the end-user is directed to adjust their arguments.
\item \code{"prod_input"}: the assertion error is considered to be an internal error,
and the end-user is directed to report it; the inputs of some function
were not as expected
\item \code{"dev_input"}: only the developer is notified (see
\verb{[dbc::set_dev_mode]})
\item \code{"prod_output"}: like \code{"prod_input"}, but the output of some function
was not as expected
\item \code{"dev_output"}: like \code{"prod_output"}, but only raised in development mode
(see \verb{[dbc::set_dev_mode]})
\item \code{"prod_interim"}: like \code{"prod_input"}, but the interim result somewhere
was not as expected
\item \code{"dev_interim"}: like \code{"prod_interim"}, but only raised in development mode
(see \verb{[dbc::set_dev_mode]})
}}

\item{raise_error_call}{\verb{[NULL, language]} (default \code{NULL})

the call to display in the error call; passed to arg \code{call} of
\link[base:conditions]{base::simpleError}.
\itemize{
\item \code{NULL}: use the parent call; when this function is called in another
function (as it is intended to be used), the function call of the
surrounding function is used; see \strong{Examples}
\item \code{language}: this call is used as-is.
}}
}
\value{
For \code{expressions_to_report}, a \code{data.frame} with columns
\itemize{
\item \code{test}: argument \code{tests} as-is
\item \code{error}: the error message if the test resulted in an error; \code{NA} if it
did not
\item \code{pass}: \code{TRUE} if corresponding test evaluated to logical and all were
\code{TRUE}, otherwise \code{FALSE} (i.e. any \code{NA} values leads to \code{FALSE})
\item \code{n_fail}: number of elements of result of test that were \code{FALSE} or \code{NA};
if result was not a logical vector of length greater than one, this is \code{NA}
\item \code{wh_fail}: integer vector of positions of test result that were \code{FALSE}
or \code{NA}; if result was not a logical vector of length greater than one,
this is \code{NA}
\item \code{message}: the corresponding \code{fail_messages} or \code{pass_messages}
element (after interpolation) depending on \code{pass}
}
}
\description{
Collect tests into a report data.frame, raise assertion errors in failed
tests in report.
}
\section{Message interpolation}{


Simple string interpolation is supported in \code{pass_messages} and
\code{fail_messages}. For the purpose of evaluating the expression substrings
in the messages, a new empty environment (\emph{interpolation environment})
is created. This contains any objects created when the \code{expressions} element
was evaluated. It's parent environment (\emph{report environment}) contains
objects
\code{test}, \code{error}, \code{pass}, \code{n_fail}, and \code{wh_fail}, respectively. These are
the data with which the report data.frame is created, ultimately.
The parent environment of the \emph{report environment} is the same as that env
where the \code{expressions} element was evaluated.

\emph{context environment}
-> \emph{expression evaluation environment}

\emph{context environment}
-> \emph{report environment}
-> \emph{interpolation environment}

These environment tricks allows one to use objects in the
\emph{context environment} in both expression evaluation and in interpolation.
The objects in the \emph{report environment} can be used in interpolation.

Given the \emph{interpolation environment} and a string, interpolation is
performed as follows:
\enumerate{
\item Expressions to interpolate in a string are detected using regex
\code{"[$][{][^{]+[}]"}. E.g. in \code{"A total of $ {1 + 1} things"}
substring \verb{$ \{1 + 1\}} is detected (without the whitespace after $).
Multiline expressions are not detected.
Expressions that contain \verb{\}} (e.g. \code{"One is $ {{my_var <- 1; my_var}}"})
will not be parsed correctly.
\item Each expression substring is evaluated in the
\emph{interpolation environment}, via
\code{eval(parse(text = expression_substring)[[1]])}.
Evaluation is done within a \verb{[tryCatch]} call; if an error or warning
is caught, interpolation fails, and the original expression substring
is used as the result of the evaluation. Otherwise the result is
what \code{eval} gives.
\item Each expression substring in the original string is substituted with
its result. This modified string is returned.
}
}

\examples{
# expressions_to_report

a <- 1:5
b <- 1:5
# pass
expressions_to_report(
  expressions = "a == b"
)
# pass
expressions_to_report(
  expressions = list(quote(a == b))
)
# expressions_to_report raises error
out <- tryCatch(expressions_to_report(
  expressions = a == (b + 1)
), error = function(e) e)
stopifnot(inherits(out, "error"))
# fail
expressions_to_report(
  expressions = "a == (b + 1)"
)
# expressions_to_report does not raise error, but shows it in output
expressions_to_report(
  expressions = "a == d"
)

# interpolation example
a <- 1
rdf <- dbc::expressions_to_report(
  expressions = "a == 1",
  pass_messages = "a was ${a} as expected",
  env = environment()
)
stopifnot(
  rdf[["message"]] == "a was 1 as expected"
)

# interpolation example
a <- 1:4
rdf <- dbc::expressions_to_report(
  expressions = "(a_len <- length(a)) == 5L",
  pass_messages = "Length of a was ${a_len} as expected",
  fail_messages = "Length of a was ${a_len}; 5 was expected",
  env = environment()
)
stopifnot(
  rdf[["message"]] == "Length of a was 4; 5 was expected"
)
# report to assertion

# pass
report_df <- expressions_to_report("1 == 1")
report_to_assertion(report_df)

# fail
report_df <- expressions_to_report("1 == 2")
tryCatch(
  report_to_assertion(report_df),
  error = function(e) e
)

# 2 passes, 2 failures
report_df <- expressions_to_report(c("1 == 2", "1 == 1", "2 == 2", "2 == 1"))
tryCatch(
  report_to_assertion(report_df),
  error = function(e) e
)

my_fun <- function(my_arg) {
  report_to_assertion(expressions_to_report("is.character(my_arg)"))
}
tryCatch(
  my_fun(my_arg = 1L),
  error = function(e) e
)
}
