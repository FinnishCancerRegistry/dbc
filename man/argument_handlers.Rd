% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{argument_handlers}
\alias{argument_handlers}
\alias{handle_arg_call}
\alias{handle_arg_x_nm}
\alias{handle_args_inplace}
\title{Argument Handlers}
\usage{
handle_arg_call(call = NULL, env = NULL)

handle_arg_x_nm(x_nm, env = NULL, arg_nm = "x")

handle_args_inplace(env = NULL)
}
\arguments{
\item{call}{\verb{[language, NULL]} (optional, default \code{NULL})
\itemize{
\item \code{language}: an R language object such as one produced by \link{match.call} or
\code{quote}; this call will be reported in an error
\item \code{NULL}: the call is attempted to be inferred
}}

\item{env}{\verb{[NULL, environment, other]} (optional, default \code{NULL})
\itemize{
\item \code{NULL}: Use \code{parent.frame(1L)} or \code{parent.frame(2L)} --- see below.
\item \code{environment}: Use this environment.
}

For \code{dbc::handle_arg_call} and \code{dbc::handle_arg_x_nm}, the temporary
evaluation environment of the
"main" function (the environment where the assertion function
was called in). Hence the default for these is \code{parent.frame(2L)}.

For others, the
evaluation environment of the assertion / report / test function. Their
default is \code{parent.frame(1L)}.}

\item{x_nm}{\verb{[NULL, character]} (optional, default \code{NULL})

the name of the object \code{x} to mention in possible error message.
\itemize{
\item \code{NULL}: taken as \code{deparse(substitute(x))}
\item \code{character}: the name as a string
}}

\item{arg_nm}{\verb{[character]} (default \code{"x"})

Actual name of argument, which must exist in \code{env}.}
}
\value{
\itemize{
\item \code{dbc::handle_arg_call}: returns an R \code{language} object, or \code{NULL} upon
failure to guess the call
}

\itemize{
\item \code{dbc::handle_arg_x_nm}: always returns a character vector of length 1
}

\itemize{
\item \code{dbc::handle_args_inplace}: always \code{NULL} invisibly.
}
}
\description{
Functions which handle arguments of check functions.
}
\section{Functions}{

\itemize{
\item \code{dbc::handle_arg_call} is used internally in other functions
to guess \code{call} which is to be reported if there is a problem
}


\itemize{
\item \code{dbc::handle_arg_x_nm} is used internally in other functions
to guess the name of the object passed to argument \code{x} when it is not
supplied explicitly. It uses object \code{x} in its caller environment
to guess \code{x_nm} if it is \code{NULL}.
}


\itemize{
\item \code{dbc::handle_args_inplace} calls \code{dbc::handle_arg_x_nm},
\code{dbc::handle_arg_call}, and \code{dbc::handle_arg_assertion_type} in its
calling env (by default). It also handles \code{x} and \code{env}:
It checks that \code{x} is not
missing and uses the calling env of the function that called
\code{dbc::handle_args_inplace} if \code{env} is \code{NULL}.
}
}

\examples{

# dbc::handle_arg_call
my_assert_fun <- function(x, x.nm = NULL, call = NULL) {
  return(dbc::handle_arg_call(call))
}
my_fun <- function(x) {
  return(my_assert_fun(x))
}
obs <- my_fun(1L)
stopifnot(
  deparse1(obs) == "my_fun(x = 1L)"
)

# dbc::handle_arg_x_nm
my_assert_fun <- function(x, x_nm = NULL, y, y_nm = NULL) {
  x_nm <- dbc::handle_arg_x_nm(x_nm)
  y_nm <- dbc::handle_arg_x_nm(y_nm, arg_nm = "y")
  return(mget(c("x_nm", "y_nm")))
}
my_fun <- function(x, y) {
  my_assert_fun(x = x, y = y)
}
obj_for_x <- 1
obj_for_y <- 2
stopifnot(
  identical(
    my_fun(x = obj_for_x, y = obj_for_y),
    list(x_nm = "obj_for_x", y_nm = "obj_for_y")
  ),
  identical(
    my_assert_fun(x = 11, y = 22),
    list(x_nm = "11", y_nm = "22")
  )
)

# dbc::handle_args_inplace
my_assert_fun <- function(
  x,
  y,
  x_nm = NULL,
  y_nm = NULL,
  call = NULL,
  assertion_type = NULL,
  env = NULL
) {
  dbc::handle_args_inplace()
  return(mget(ls()))
}
my_fun <- function(
  x,
  y
) {
  return(my_assert_fun(x, y))
}
obs <- my_fun(11, 22)
stopifnot(
  identical(obs[["x_nm"]], "11"),
  identical(obs[["y_nm"]], "22"),
  identical(deparse1(obs[["call"]]), "my_fun(x = 11, y = 22)"),
  identical(obs[["assertion_type"]], dbc::assertion_type_default()),
  names(formals(my_fun)) \%in\% ls(obs[["env"]])
)
}
