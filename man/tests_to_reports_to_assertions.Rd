% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/function_generation.R
\name{tests_to_reports_to_assertions}
\alias{tests_to_reports_to_assertions}
\alias{tests_to_report}
\alias{report_to_assertion}
\title{Tests to Reports to Assertions}
\usage{
tests_to_report(
  tests,
  fail_messages = NULL,
  pass_messages = NULL,
  env = parent.frame(1L)
)

report_to_assertion(report_df)
}
\arguments{
\item{tests}{\verb{[character]} (mandatory, no default)

character string vector of tests to perform; after parsing each string
the evaluated expression must return a logical vector or \code{NULL},
where \code{NULL} is interpreted as pass}

\item{fail_messages}{\verb{[NULL, character]} (optional, default \code{NULL})
\itemize{
\item \code{NULL}: use \code{"at least one FALSE value in test: ${test}"}
\item \code{character}: use these messages (one for each test); \code{NA_character_}
values are replaced with the same message as when this argument is
\code{NULL}
}

messages (one for each test) to include in report upon failure; see section
\strong{Interpolation in messages}}

\item{pass_messages}{\verb{[NULL, character]} (optional, default \code{NULL})
\itemize{
\item \code{NULL}: use \code{"all were TRUE in test: ${test}"}
\item \code{character}: use these messages (one for each test); \code{NA_character_}
values are replaced with the same message as when this argument is
\code{NULL}
}

as \code{fail_messages} but for tests successes}

\item{env}{\verb{[environment]} (optional, default \code{parent.frame(1L)})

a new environment is created for evaluating each test given in \code{tests};
this environment will be the parent environment of each of the temporary
environments; the default is the parent environment of the function execution
environment}

\item{report_df}{\verb{[data.frame]} (mandatory, no default)

a report \code{data.frame} as returned by \code{tests_to_report}}
}
\value{
For \code{tests_to_report}, a \code{data.frame} with columns
\itemize{
\item \code{test}: argument \code{tests} as-is
\item \code{error}: the error message if the test resulted in an error; \code{NA} if it
did not
\item \code{pass}: \code{TRUE} if corresponding test evaluated to logical and all were
\code{TRUE}, otherwise \code{FALSE} (i.e. any \code{NA} values leads to \code{FALSE})
\item \code{n_fail}: number of elements of result of test that were \code{FALSE} or \code{NA};
if result was not a logical vector of length greater than one, this is \code{NA}
\item \code{wh_fail}: integer vector of positions of test result that were \code{FALSE}
or \code{NA}; if result was not a logical vector of length greater than one,
this is \code{NA}
\item \code{message}: the corresponding \code{fail_messages} or \code{pass_messages}
element (after interpolation) depending on \code{pass}
}
}
\description{
Collect tests into a report data.frame, raise assertion errors in failed
tests in report.
}
\section{Interpolation in messages}{

\code{fail_messages} and \code{pass_messages} can use variables you create in a test
and information created based on the result of the test. For an individual
message, you may include any of the variables listed in \strong{Value} for that
test except the message itself by using the syntax \verb{$\{object\}} in your
test string; e.g. \code{"this many failed: ${n_fail}"}. You may include any
variables you created in the test, using the same logic, e.g. with test
\code{"(len <- length(x)) == 1L"} you may do \code{"expected length 1, got ${len}"}.
Finding variables to interpolate into the string is searched for in the
set of variables created in your test first and then in the variables
derived from the result of the test.
}

\examples{
# tests_to_report

a <- 1:5
b <- 1:5
# pass
tests_to_report(
  tests = "a == b"
)
# fail
tests_to_report(
  tests = "a == (b + 1)"
)
# error
tests_to_report(
  tests = "a == c"
)
# report to assertion

# pass
report_df <- tests_to_report("1 == 1")
report_to_assertion(report_df)

# fail
report_df <- tests_to_report("1 == 2")
tryCatch(
  report_to_assertion(report_df),
  error = function(e) e
)

# 2 passes, 2 failures
report_df <- tests_to_report(c("1 == 2", "1 == 1", "2 == 2", "2 == 1"))
tryCatch(
  report_to_assertion(report_df),
  error = function(e) e
)
}
